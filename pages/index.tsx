import {Fragment, ReactElement, ReactNode, useEffect} from 'react'
import Head from 'next/head'
import Image from 'next/image'
import {Inter} from '@next/font/google'
import {GetServerSideProps, NextPage} from 'next'

import {Price, Prisma, PrismaClient, Product, Region} from '@prisma/client'

import EditItem from '../stores/EditItem'
import ListStore from '../stores/ListStore'


import sty from '../styles/home.module.sass'



const inter = Inter({subsets: ['latin']})


const region = new EditItem<Region>('region')
const product = new EditItem<Product>('product')
const price = new EditItem<Price>('price')


const regionList = new ListStore<Region>('region')
const productList = new ListStore<Product>('product')
const priceList = new ListStore<Price>('price')


const submit = (newItem: EditItem, list: ListStore<any>) => {
	newItem.submit().then(async st => {
		if (st == 'ok') {
			await list.fetch()
			await priceList.forceRefresh()
		}
	})
}

const NewItem = (p: {
	name: string
	children: ReactNode
	edit: EditItem
	list: ListStore<any>
}) => {
	const opened = p.edit.useOpened()
	return opened ? <div className={sty.newItem}>
		{p.children}
		<span onClick={_ => submit(p.edit, p.list)} />
		<span onClick={_ => p.edit.cancel()} />
	</div> : <ToggleNew id={'toggler_new_' + p.name} item={p.edit} />
}

const NewRegion = () => {
	return <NewItem name='region' edit={region} list={regionList}>
		<input onChange={e => region.value.name = e.target.value} />
		<input onChange={e => region.value.code = e.target.value} />
	</NewItem>
}


const NewProduct = () => {
	return <NewItem name='product' edit={product} list={productList}>
		<input onChange={e => product.value.name = e.target.value} />
	</NewItem>
}


const Select = <T,>(p: { store: [EditItem<T>, ListStore<any>], valueName: keyof T }) => {
	p.store[1].useStatus()
	return <select onChange={e =>
		//@ts-ignore
		p.store[0].value[p.valueName] = parseInt(e.target.value)
	}>
		<option value={undefined}>выберите</option>
		{
			p.store[1].items.map(it =>
				<option key={it.id} value={it.id}>{it.name}</option>
			)
		}
	</select>
}

const NewPrice = () => {
	return <NewItem name='price' edit={price} list={priceList}>
		<Select<Price> store={[price, regionList]} valueName='regionId' />
		<Select<Price> store={[price, productList]} valueName='productId' />
		<input onChange={e => price.value.price = parseFloat(e.target.value)} />
	</NewItem>
}



const ToggleNew = (p: { id: string, item: EditItem }) => {
	return <span className={sty.toggleNew}>
		<input
			type='checkbox' id={p.id}
			onClick={e => p.item.opened = e.currentTarget.checked} />
		<label htmlFor={p.id}> новая</label>
	</span>
}


const List = <T extends Id,>(p: {
	store: ListStore<T>
}) => {
	const status = p.store.useStatus()
	const remove = async (id: number) => {
		const res = await p.store.remove(id)
		if (res)
			priceList.fetch()
	}
	
	return !status ? <>загрузка</> : <div className={sty.list}>{
		p.store.items.map((it, i) => <div key={i}>
			{it['name']}
			<i onClick={_ => remove(it.id)}>&ndash;</i>
		</div>)
	}</div>
}



type Props = {
	regions: Region[]
	products: Product[]
	prices: Price[]
}

const regionMap: Record<number, string> = {}
const productMap: Record<number, string> = {}

regionList.status.subscribe(v => {
	regionList.items.map(it => regionMap[it.id] = it.name)
})

productList.status.subscribe(v => {
	productList.items.map(it => productMap[it.id] = it.name)
})

const PriceList = () => {
	const st = priceList.useStatus()
	const counts = {}
	const items = priceList.items.sort((it1, it2) =>
		it1.regionId > it2.regionId ? 1 : -1
	)
	const render = (it: Price) =>
		!counts[it.regionId] && (
			counts[it.regionId] = true, <b style={{ gridColumn: 'span 3' }}>{regionMap[it.regionId]}</b>
		)

	return <div className={sty.prices}>{
		items.map(it => <Fragment key={it.id}>
			{render(it)}
			<span>{productMap[it.productId]}</span>
			<span>{it.price}</span>
			<i onClick={_ => priceList.remove(it.id)}>&ndash;</i>
		</Fragment>)}
	</div>
}

const Home: NextPage<Props> = p => {
	useEffect(() => {
		regionList.items = p.regions
		productList.items = p.products
		priceList.items = p.prices
		
		regionList.forceRefresh()
		productList.forceRefresh()
		priceList.forceRefresh()
	}, [])

	return (
		<>
			<Head>
				<title>Create Next App</title>
				<meta name="description" content="Generated by create next app"/>
				<meta name="viewport" content="width=device-width, initial-scale=1"/>
				<link rel="icon" href="/favicon.ico"/>
			</Head>

			<main className={sty.main}>
				<div className={sty.tabs}>
					<input type='radio' id='toggler1' name='toggler' />
					<label htmlFor='toggler1'>Регионы</label>
					
					<input type='radio' id='toggler2' name='toggler' />
					<label htmlFor='toggler2'>Продукты</label>
					
					<input type='radio' id='toggler3' name='toggler' />
					<label htmlFor='toggler3'>Цены</label>
					
					<div id='tab1'>
						<List store={regionList} />
						<hr />
						<NewRegion />
					</div>
					<div id='tab2'>
						<List store={productList} />
						<hr />
						<NewProduct />
					</div>
					<div id='tab3'>
						<PriceList />
						<hr />
						<NewPrice />
					</div>
				</div>
			</main>
		</>
	)
}


export default Home

export const getServerSideProps: GetServerSideProps<Props> = async () => {
	const prisma = new PrismaClient()
	const regions = await prisma.region.findMany()
		, products = await prisma.product.findMany()
		, prices = await prisma.price.findMany()
	//console.log(regions)
	return {
		props: {
			regions, products, prices
		}
	}
}